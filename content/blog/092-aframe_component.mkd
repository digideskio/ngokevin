title: "How to Write an A-Frame VR Component"
type: blog
category: blog
date: 2016-01-17
slug: aframe-component
tags: [code]

image:
  url:
  caption:
---

[boilerplate]: https://github.com/ngokevin/aframe-component-boilerplate
[changelog]: https://github.com/aframevr/aframe/blob/dev/CHANGELOG.md#dev
[collide]: https://github.com/dmarcos/a-invaders/tree/master/js/components)
[docs]: https://aframe.io/docs/core/
[follow]: https://jsbin.com/dasefeh/edit?html,output
[geometry]: https://aframe.io/docs/components/geometry.html
[light]: https://aframe.io/docs/components/light.html
[physics]: https://github.com/ngokevin/aframe-physics-components
[position]: https://aframe.io/docs/components/position.html
[rotation]: https://aframe.io/docs/components/rotation.html
[three]: http://threejs.org/
[visible]: https://aframe.io/docs/components/visible.html

[A-Frame](/blog/aframe) is a WebVR framework that introduces the
[entity-component system](/blog/aframe-vs-3dml) ([docs](docs)) to the DOM. The
entity-component system treats every **entity** in the scene as a placeholder
object which we apply and mix **components** to in order to add appearance,
behavior, and functionality. A-Frame comes with some standard components out of
the box like camera, geometry, material, light, or sound. However, people can
write, publish, and register their own components to do **whatever** they want
like have entities [collide/explode/spawn][collide] be controlled by
[physics][physics], or [follow a path][follow]. Today, we'll be going through
how we can write our own A-Frame components.

> Note that this tutorial will be covering the upcoming release of [A-Frame
0.2.0][changelog] which vastly improves the component API.

---

## What a Component Looks Like

A component is a bucket of data in the form of properties. Let's first see what
a component looks like from the DOM.

For example, the [light component][light] has properties such as type, color,
and intensity. In A-Frame, we register and configure a component to an entity
using an HTML attribute and a style-like syntax:

    ::html
    <a-entity light="type: point; color: crimson; intensity: 2.5"></a-entity>

This would give us a light in the scene. To demonstrate composability, we could
give the light a spherical representation by mixing in the [geometry
component][geometry].

    ::html
    <a-entity geometry="primitive: sphere; radius: 5"
              light="type: point; color: crimson; intensity: 2.5"></a-entity>

Or we can configure the position component to move the light sphere a bit to the right.

    ::html
    <a-entity geometry="primitive: sphere; radius: 5"
              light="type: point; color: crimson; intensity: 2.5"
              position="5 0 0"></a-entity>

## What a Component Looks Like, Under the Hood

Now let's see what a component looks like **under the hood**. A-Frame's most
basic component is the [position component][position]:

    ::js
    AFRAME.registerComponent('position', {
      schema: { type: 'vec3' },

      update: function () {
        var object3D = this.el.object3D;
        var data = this.data;
        object3D.position.set(data.x, data.y, data.z);
      }
    });

The position component uses only a tiny subset of the component API, but what
this does is register the component with the name "position", define a `schema`
where the component's value with be parsed to an `{x, y, z}` object, and when
the component initializes or the component's data updates, set the position of
the entity with the `update` callback. `this.el` is a reference from the
component to the DOM element, or entity, and `object3D` is the entity's
[three.js][three]. Note that A-Frame is built on top of three.js so many
components will be using the three.js API.

So we see that components consist of a name and a definition, and then they can
be registered to A-Frame. We saw the the position component definition defined
a `schema` and an `update` handler. Components simply consist of the `schema`,
which defines the shape of the data, and several handlers for the component to
modify the entity in reaction to different types of events.

Here is the complete list of properties and methods of a component definition:

| Definition Property | Description |
| ------------------  | ----------- |
| schema              | Names, types, and default values of the component property value(s).
| init                | Called once when the component is initialized.
| update              | Called both when the component is initialized and whenever the component's data changes (e.g, via `setAttribute`).
| remove              | Called when the component detaches from the element (e.g., via `removeAttribute`).
| tick                | Called on each render loop or tick of the scene.
| pause               | Called whenever the scene or entity pauses to remove any background or dynamic behavior.
| play                | Called whenever the scene or entity plays to add any background or dynamic behavior.

## Defining the Schema

The component's schema defines what type of data it takes. A component can
either be single-property or consist of multiple properties. And properties
have *property types*. Note that single-property schemas and property types are
being released in A-Frame `v0.2.0`.

A property might look like:

    ::js
    { type: 'int', default: 5 }

And a schema consisting of multiple properties might look like:

    ::js
    {
      color: { default: '#FFF' },
      target: { type: 'selector' },
      uv: {
        default: '1 1',
        parse: function (value) {
          return value.split(' ').map(parseFloat);
        }
      },
    }

Since components in the entity-component system are just buckets of data that
are used to affect the appearance or behavior of the entity, the schema plays a
crucial role in the definition of the component.

### Property Types

A-Frame comes with several built-in property types such as `boolean`, `int`,
`number`, `selector`, `string`, or `vec3`. Every single property is assigned a
type, whether explicitly through the `type` key or implictly via inferring the
value. And each type is used to assign `parse` and `stringify` functions. The
parser deserializes the incoming string value from the DOM to be put into the
component's data object. The stringifier is used when using `setAttribute` to
serialize back to the DOM.

We can actually define and register our own property types:

    ::js
    AFRAME.registerPropertyType('radians', {
      parse: function () {

      }

      // Default stringify is .toString().
    });

### Single-Property Schemas

If a component has only one property, then it must either have a `type` or a
`default` value. If the type is defined, then the type is used to parse and
coerce the string retrieved from the DOM (e.g., `getAttribute`). Or if the
default value is defined, the default value is used to infer the type.

Take for instance the [visible component][visible]. The schema property
definition implicitly defines it as a boolean:

    ::js
    AFRAME.registerComponent('visible', {
      schema: {
        // Type will be inferred to be boolean.
        default: true
      },

      // ...
    });

Or the [rotation component][rotation] which explicitly defines the value as a `vec3`:

    ::js
    AFRAME.registerComponent('rotation', {
      schema: {
        // Default value will be 0, 0, 0 as defined by the vec3 property type.
        type: 'vec3'
      }

      // ...
    });

Using these defined property types, schemas are processed by
`registerComponent` to inject default values, parsers, and stringifiers for
each property. So if a default value is not defined, the default value will be
whatever the property type defines as the "default default value".

### Multiple-Property Schemas

If a component has multiple properties (or one named property), then it consists of
one or more property definitions, in the form described above, in an object keyed by
property name. For instance, a physics body component might define a schema:

    ::js
    AFRAME.registerComponent('physics-body', {
      schema: {
        boundingBox: {
          type: 'vec3',
          default: { x: 1, y: 1, z: 1 }
        },
        mass: {
          default: 0
        },
        velocity: {
          type: 'vec3'
        }
      }
    }

Having multiple properties is what makes the component take the syntax in the
form of `physics="mass: 2; velocity: 1 1 1"`.

With the schema defined, all data coming into the component will be passed
through the schema for parsing. Then in the lifecycle methods, the component
has access to `this.data` which in a single-property schema is a value and in a
multiple-propery schema is an object.

## Defining the Lifecycle Methods

### Set Up with Component.init()

`init` is called once in the component's lifecycle when it is mounted to the
entity. `init` is generally used to set up variables or members that may used
throughout the component or to set up state. Though not every component will
need to define an `init` handler. Sort of like the component-equivalent method
to `createdCallback` or `React.ComponentDidMount`.

### Do the Magic in Component.update()

### Teardown in Component.remove()

### Background Behavior in Component.tick()

### Freeze and Melt in Component.pause() and Component.play()

## Boilerplate

I suggest that people start off with my [component boilerplate][boilerplate],
even hardcore tool junkies. The boilerplate contains a lot of tribal inside
knowledge about A-Frame and is updated frequently to reflect new things landing
on A-Frame. The boilerplate handles creating a stubbed component, build steps for both
NPM and browser distribution files, and publishing to Github Pages.

## Example: Layout Component

## Example: Text Component

## Example: Physics Component
