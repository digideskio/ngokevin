title: "AngularJS Directive for Mobile Sliders"
type: blog
category: blog

slug: "angularslider"

image:
    url: http://i.imgur.com/JM0yS3I.jpg
    where: top

date: 2013-04-09

---

I ditched jQuery Mobile's sliders for my growing AngularJS [poker
app](http://github.com/ngokevin/underthegun). It had served as the app's poker
bet slider. All I wanted was a simple slider widget from jQuery Mobile, but the
UI framework wanted me to marry it in return. It had its way with my HTML
markup, littering my DOM elements full of selfish classes and attributes, like
a garbage truck whose driver forgot to close the rear door. My CSS rules became
oppressed like liberal college students as jQuery Mobile's CSS files applied
forceful rules my top-level ```html``` and ```body``` elements. The kicker? The
slider quickly became deprecated, not working on newer versions of Firefox. I
never even saw it work on Chrome.

My disappointment digresses. The point is: I assembled my own customizable
mobile slider that hooked into AngularJS in the form of a directive. Let us
begin with the HTML, which AngularJS enhances with declarative two-way bindings.

    ::html
    <div slider class="slider" step="10">
      <span></span>
    </div>

Unfortunately, this is not the most exciting display of AngularJS's abilities.
Though by giving the element a ```bet-slider``` attribute, I make the element a
template for an AngularJS directive, which is where all the magic will happen.
Note that the following Javascript code snippets are parts of a whole.

    ::js
    var myApp = angular.module('my-app',['my-app.directives']);

    var directives = angular.module('my-app.directives', []);
    directives.directive('slider', function() {
        return {
            link: function(scope, element, attrs) {
                // Linking function.
                // {{ initialize }}
                // {{ event handler }}
                // {{ scope watcher }}
            }
        };
    });

Directives teach HTML new tricks, allowing us to write reusable components and
widgets. For this slider, all we need is the link function. The link function
allows us to register event handlers and watches on the scope, all binded to
our template. ```link``` supplies the AngularJS scope, the element acting as
the directive template, and attributes of the element. All of which will be
useful. Let us get some initialization out of the way.

     ::js
    // Linking function.
    // {{ initialize }}
    var $element = $(element);
    var $bar = $('span', $element);
    var step = attrs.step;

    var width;
    var offset;

    var mouseDown = false;
    element.on('mousedown touchstart', function(evt) {
        mouseDown = true;
        if (!width) {
            width = $element.width();
        } if (!offset) {
            offset = $bar.offset().left;
        }
    });

    element.on('mouseup touchend', function(evt) {
        mouseDown = false;
    });

This just allows us to determine whether the user is currently dragging the
slider with a click or touch. Moving on, here is what we really want to
accomplish. Whenever the user drags the slider, we want to update its binded
scope value. Whenever the binded scope value changes, we want to visually
update the slider's fill.

    ::js
    // {{ event handler }}
    element.on('mousemove touchmove', _.throttle(_pd(function(evt) {
        if (!mouseDown) {
            // Don't drag the slider on mousemove hover, only on click-n-drag.
            return;
        }

        // Calculate distance of the cursor/finger from beginning of slider
        var diff;
        if (evt.pageX) {
            diff = evt.pageX - offset;
        } else {
            diff = evt.originalEvent.touches[0].pageX - offset;
        }

        // {{ update scope }}


    ::js
        // {{ update scope }}

        // Allow dragging past the limits of the slider, but impose min/max values.
        if (diff < 0) {
            scope.sliderValue = scope.someMinAmount;
            $bar.width('0%');
        } else if (diff > width) {
            scope.sliderValue = scope.someMaxAmount;
            $bar.width('100%');

        // Set the value to percentage of slider filled against a max value.
        } else {
            var percent = diff / width;
            $bar.width(percent * 100 + '%');
            scope.sliderValue = Math.round(percent * scope.someMaxAmount / step) * step);
        }

        // Let all the watchers know we have updated the slider value.
        scope.$apply();
    }), 25));
